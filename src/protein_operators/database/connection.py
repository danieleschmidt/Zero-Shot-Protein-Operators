"""
Database connection management for protein operators.

Provides SQLAlchemy-based database connectivity with connection pooling,
transaction management, and configuration support.
"""

import os
import logging
from typing import Optional, Dict, Any, Generator
from contextlib import contextmanager
from pathlib import Path

import sqlalchemy as sa
from sqlalchemy import create_engine, MetaData
from sqlalchemy.orm import sessionmaker, Session, declarative_base
from sqlalchemy.pool import StaticPool
from sqlalchemy.engine import Engine

logger = logging.getLogger(__name__)

# Base class for all database models
Base = declarative_base()

class DatabaseManager:
    """
    Database connection and session management.
    
    Handles database connections, session lifecycle, and configuration
    for different environments (development, testing, production).
    
    Example:
        >>> db = DatabaseManager("sqlite:///protein_designs.db")
        >>> with db.session() as session:
        ...     design = ProteinDesign(...)
        ...     session.add(design)
        ...     session.commit()
    """
    
    def __init__(\n        self,\n        database_url: Optional[str] = None,\n        echo: bool = False,\n        pool_size: int = 10,\n        max_overflow: int = 20,\n        pool_timeout: int = 30,\n        pool_recycle: int = 3600,\n        **engine_kwargs\n    ):\n        \"\"\"\n        Initialize database manager.\n        \n        Args:\n            database_url: Database connection URL\n            echo: Whether to echo SQL statements\n            pool_size: Number of connections to maintain\n            max_overflow: Maximum overflow connections\n            pool_timeout: Seconds to wait for connection\n            pool_recycle: Seconds before recreating connections\n            **engine_kwargs: Additional engine arguments\n        \"\"\"\n        self.database_url = database_url or self._get_default_url()\n        self.echo = echo\n        \n        # Engine configuration\n        engine_config = {\n            \"echo\": echo,\n            \"pool_pre_ping\": True,\n            **engine_kwargs\n        }\n        \n        # Add pool configuration for non-SQLite databases\n        if not self.database_url.startswith(\"sqlite\"):\n            engine_config.update({\n                \"pool_size\": pool_size,\n                \"max_overflow\": max_overflow,\n                \"pool_timeout\": pool_timeout,\n                \"pool_recycle\": pool_recycle,\n            })\n        else:\n            # SQLite-specific configuration\n            engine_config.update({\n                \"poolclass\": StaticPool,\n                \"connect_args\": {\"check_same_thread\": False}\n            })\n        \n        # Create engine and session factory\n        self._engine = create_engine(self.database_url, **engine_config)\n        self._session_factory = sessionmaker(bind=self._engine)\n        \n        logger.info(f\"Database manager initialized with URL: {self._mask_url(self.database_url)}\")\n    \n    @staticmethod\n    def _get_default_url() -> str:\n        \"\"\"Get default database URL from environment.\"\"\"\n        default_url = os.getenv(\n            \"DATABASE_URL\", \n            \"sqlite:///data/protein_operators.db\"\n        )\n        \n        # Ensure SQLite database directory exists\n        if default_url.startswith(\"sqlite\"):\n            db_path = default_url.replace(\"sqlite:///\", \"\")\n            Path(db_path).parent.mkdir(parents=True, exist_ok=True)\n        \n        return default_url\n    \n    @staticmethod\n    def _mask_url(url: str) -> str:\n        \"\"\"Mask sensitive information in database URL.\"\"\"\n        if \"://\" in url and \"@\" in url:\n            scheme, rest = url.split(\"://\", 1)\n            if \"@\" in rest:\n                credentials, host_part = rest.rsplit(\"@\", 1)\n                return f\"{scheme}://***:***@{host_part}\"\n        return url\n    \n    @property\n    def engine(self) -> Engine:\n        \"\"\"Get SQLAlchemy engine.\"\"\"\n        return self._engine\n    \n    @contextmanager\n    def session(self) -> Generator[Session, None, None]:\n        \"\"\"\n        Context manager for database sessions.\n        \n        Provides automatic session management with proper cleanup\n        and transaction handling.\n        \n        Yields:\n            Database session\n            \n        Example:\n            >>> with db.session() as session:\n            ...     design = session.query(ProteinDesign).first()\n            ...     design.name = \"Updated Name\"\n            ...     session.commit()\n        \"\"\"\n        session = self._session_factory()\n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            session.rollback()\n            logger.error(f\"Database session error: {e}\")\n            raise\n        finally:\n            session.close()\n    \n    def create_tables(self, drop_first: bool = False) -> None:\n        \"\"\"\n        Create all database tables.\n        \n        Args:\n            drop_first: Whether to drop existing tables first\n        \"\"\"\n        if drop_first:\n            logger.warning(\"Dropping all existing tables\")\n            Base.metadata.drop_all(self._engine)\n        \n        logger.info(\"Creating database tables\")\n        Base.metadata.create_all(self._engine)\n    \n    def drop_tables(self) -> None:\n        \"\"\"Drop all database tables.\"\"\"\n        logger.warning(\"Dropping all database tables\")\n        Base.metadata.drop_all(self._engine)\n    \n    def get_table_info(self) -> Dict[str, Any]:\n        \"\"\"Get information about database tables.\"\"\"\n        inspector = sa.inspect(self._engine)\n        tables = inspector.get_table_names()\n        \n        table_info = {}\n        for table_name in tables:\n            columns = inspector.get_columns(table_name)\n            indexes = inspector.get_indexes(table_name)\n            table_info[table_name] = {\n                \"columns\": columns,\n                \"indexes\": indexes\n            }\n        \n        return table_info\n    \n    def execute_raw_sql(self, sql: str, params: Optional[Dict] = None) -> Any:\n        \"\"\"\n        Execute raw SQL statement.\n        \n        Args:\n            sql: SQL statement\n            params: Query parameters\n            \n        Returns:\n            Query result\n        \"\"\"\n        with self.session() as session:\n            result = session.execute(sa.text(sql), params or {})\n            return result.fetchall()\n    \n    def backup_database(self, backup_path: str) -> None:\n        \"\"\"\n        Create database backup (SQLite only).\n        \n        Args:\n            backup_path: Path for backup file\n        \"\"\"\n        if not self.database_url.startswith(\"sqlite\"):\n            raise NotImplementedError(\"Backup only supported for SQLite\")\n        \n        import sqlite3\n        import shutil\n        \n        # Extract database path\n        db_path = self.database_url.replace(\"sqlite:///\", \"\")\n        \n        # Create backup\n        shutil.copy2(db_path, backup_path)\n        logger.info(f\"Database backed up to {backup_path}\")\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        Get database statistics.\n        \n        Returns:\n            Dictionary with database statistics\n        \"\"\"\n        stats = {\n            \"url\": self._mask_url(self.database_url),\n            \"engine\": str(self._engine),\n            \"pool_size\": getattr(self._engine.pool, \"size\", \"N/A\"),\n            \"checked_out\": getattr(self._engine.pool, \"checked_out\", \"N/A\"),\n        }\n        \n        # Get table counts\n        with self.session() as session:\n            table_counts = {}\n            inspector = sa.inspect(self._engine)\n            for table_name in inspector.get_table_names():\n                try:\n                    count = session.execute(\n                        sa.text(f\"SELECT COUNT(*) FROM {table_name}\")\n                    ).scalar()\n                    table_counts[table_name] = count\n                except Exception as e:\n                    table_counts[table_name] = f\"Error: {e}\"\n            \n            stats[\"table_counts\"] = table_counts\n        \n        return stats\n    \n    def close(self) -> None:\n        \"\"\"Close database connections.\"\"\"\n        logger.info(\"Closing database connections\")\n        self._engine.dispose()\n\n\n# Global database instance\n_db_instance: Optional[DatabaseManager] = None\n\n\ndef get_database(\n    database_url: Optional[str] = None,\n    echo: Optional[bool] = None,\n    force_new: bool = False\n) -> DatabaseManager:\n    \"\"\"\n    Get or create global database instance.\n    \n    Args:\n        database_url: Database connection URL\n        echo: Whether to echo SQL statements\n        force_new: Force creation of new instance\n        \n    Returns:\n        Database manager instance\n    \"\"\"\n    global _db_instance\n    \n    if _db_instance is None or force_new:\n        # Use environment defaults if not specified\n        if database_url is None:\n            database_url = os.getenv(\"DATABASE_URL\")\n        if echo is None:\n            echo = os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\"\n        \n        _db_instance = DatabaseManager(\n            database_url=database_url,\n            echo=echo\n        )\n    \n    return _db_instance\n\n\ndef reset_database() -> None:\n    \"\"\"Reset global database instance.\"\"\"\n    global _db_instance\n    if _db_instance:\n        _db_instance.close()\n    _db_instance = None\n\n\nclass DatabaseConfig:\n    \"\"\"\n    Database configuration management.\n    \n    Handles different database configurations for various environments.\n    \"\"\"\n    \n    @staticmethod\n    def development() -> Dict[str, Any]:\n        \"\"\"Development database configuration.\"\"\"\n        return {\n            \"database_url\": \"sqlite:///data/protein_operators_dev.db\",\n            \"echo\": True,\n            \"pool_size\": 5,\n            \"max_overflow\": 10,\n        }\n    \n    @staticmethod\n    def testing() -> Dict[str, Any]:\n        \"\"\"Testing database configuration.\"\"\"\n        return {\n            \"database_url\": \"sqlite:///:memory:\",\n            \"echo\": False,\n            \"pool_size\": 1,\n            \"max_overflow\": 0,\n        }\n    \n    @staticmethod\n    def production() -> Dict[str, Any]:\n        \"\"\"Production database configuration.\"\"\"\n        return {\n            \"database_url\": os.getenv(\n                \"DATABASE_URL\",\n                \"postgresql://user:password@localhost/protein_operators\"\n            ),\n            \"echo\": False,\n            \"pool_size\": 20,\n            \"max_overflow\": 30,\n            \"pool_timeout\": 30,\n            \"pool_recycle\": 3600,\n        }\n    \n    @classmethod\n    def from_env(cls) -> Dict[str, Any]:\n        \"\"\"Get configuration from environment.\"\"\"\n        env = os.getenv(\"APP_ENV\", \"development\").lower()\n        \n        if env == \"production\":\n            return cls.production()\n        elif env == \"testing\":\n            return cls.testing()\n        else:\n            return cls.development()