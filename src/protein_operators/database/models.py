"""
SQLAlchemy models for protein design database.

Defines database schema for storing protein designs, experiments,
constraints, and validation results.
"""

import json
from datetime import datetime
from typing import Dict, Any, List, Optional
from uuid import uuid4

import sqlalchemy as sa
from sqlalchemy import Column, String, Integer, Float, Text, DateTime, Boolean, ForeignKey, JSON
from sqlalchemy.orm import relationship, validates
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.hybrid import hybrid_property

from .connection import Base

class TimestampMixin:
    \"\"\"Mixin for automatic timestamps.\"\"\"\n    \n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)\n\n\nclass UUIDMixin:\n    \"\"\"Mixin for UUID primary keys.\"\"\"\n    \n    id = Column(\n        String(36),  # Use String for SQLite compatibility\n        primary_key=True,\n        default=lambda: str(uuid4()),\n        nullable=False\n    )\n\n\nclass ProteinDesign(Base, UUIDMixin, TimestampMixin):\n    \"\"\"\n    Protein design storage model.\n    \n    Stores generated protein structures with metadata, constraints,\n    and validation results.\n    \"\"\"\n    \n    __tablename__ = \"protein_designs\"\n    \n    # Basic information\n    name = Column(String(255), nullable=False, index=True)\n    description = Column(Text)\n    sequence = Column(Text)  # Amino acid sequence\n    length = Column(Integer, nullable=False)\n    \n    # Design parameters\n    operator_type = Column(String(50), nullable=False)  # deeponet, fno, etc.\n    model_version = Column(String(50))\n    model_checkpoint = Column(String(255))\n    \n    # Structure data\n    coordinates_json = Column(Text)  # JSON-encoded coordinates\n    structure_format = Column(String(10), default=\"xyz\")  # xyz, pdb, etc.\n    structure_path = Column(String(500))  # Path to structure file\n    \n    # Design metadata\n    design_method = Column(String(100))\n    generation_time_seconds = Column(Float)\n    num_samples_generated = Column(Integer, default=1)\n    \n    # Status and flags\n    status = Column(String(50), default=\"generated\")  # generated, validated, failed\n    is_validated = Column(Boolean, default=False)\n    is_experimental = Column(Boolean, default=False)\n    \n    # Design context\n    experiment_id = Column(String(36), ForeignKey(\"experiments.id\"), index=True)\n    parent_design_id = Column(String(36), ForeignKey(\"protein_designs.id\"))\n    \n    # Relationships\n    experiment = relationship(\"Experiment\", back_populates=\"designs\")\n    parent_design = relationship(\"ProteinDesign\", remote_side=[id])\n    child_designs = relationship(\"ProteinDesign\", backref=\"parent\")\n    constraints = relationship(\"Constraint\", back_populates=\"design\")\n    validation_results = relationship(\"ValidationResult\", back_populates=\"design\")\n    performance_metrics = relationship(\"PerformanceMetric\", back_populates=\"design\")\n    \n    @hybrid_property\n    def coordinates(self) -> Optional[List[List[float]]]:\n        \"\"\"Get coordinates as Python list.\"\"\"\n        if self.coordinates_json:\n            return json.loads(self.coordinates_json)\n        return None\n    \n    @coordinates.setter\n    def coordinates(self, value: List[List[float]]) -> None:\n        \"\"\"Set coordinates from Python list.\"\"\"\n        self.coordinates_json = json.dumps(value) if value is not None else None\n    \n    @validates('status')\n    def validate_status(self, key: str, status: str) -> str:\n        \"\"\"Validate status values.\"\"\"\n        allowed_statuses = ['generated', 'validated', 'failed', 'optimized', 'experimental']\n        if status not in allowed_statuses:\n            raise ValueError(f\"Status must be one of {allowed_statuses}\")\n        return status\n    \n    @validates('operator_type')\n    def validate_operator_type(self, key: str, operator_type: str) -> str:\n        \"\"\"Validate operator type.\"\"\"\n        allowed_types = ['deeponet', 'fno', 'transformer', 'cnn', 'hybrid']\n        if operator_type not in allowed_types:\n            raise ValueError(f\"Operator type must be one of {allowed_types}\")\n        return operator_type\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"Get design summary.\"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"length\": self.length,\n            \"operator_type\": self.operator_type,\n            \"status\": self.status,\n            \"is_validated\": self.is_validated,\n            \"created_at\": self.created_at.isoformat(),\n            \"generation_time\": self.generation_time_seconds\n        }\n    \n    def __repr__(self) -> str:\n        return f\"<ProteinDesign(id='{self.id}', name='{self.name}', length={self.length})>\"\n\n\nclass Experiment(Base, UUIDMixin, TimestampMixin):\n    \"\"\"\n    Experiment tracking model.\n    \n    Groups related protein designs and tracks experimental parameters.\n    \"\"\"\n    \n    __tablename__ = \"experiments\"\n    \n    # Basic information\n    name = Column(String(255), nullable=False, index=True)\n    description = Column(Text)\n    objective = Column(Text)  # Experiment objective\n    \n    # Experiment parameters\n    parameters_json = Column(Text)  # JSON-encoded parameters\n    \n    # Status and metadata\n    status = Column(String(50), default=\"running\")  # running, completed, failed, paused\n    started_at = Column(DateTime, default=datetime.utcnow)\n    completed_at = Column(DateTime)\n    \n    # Performance tracking\n    num_designs = Column(Integer, default=0)\n    success_rate = Column(Float)\n    best_score = Column(Float)\n    \n    # User and project info\n    user_id = Column(String(100))\n    project_name = Column(String(255))\n    tags_json = Column(Text)  # JSON-encoded tags\n    \n    # Relationships\n    designs = relationship(\"ProteinDesign\", back_populates=\"experiment\")\n    \n    @hybrid_property\n    def parameters(self) -> Dict[str, Any]:\n        \"\"\"Get parameters as Python dict.\"\"\"\n        if self.parameters_json:\n            return json.loads(self.parameters_json)\n        return {}\n    \n    @parameters.setter\n    def parameters(self, value: Dict[str, Any]) -> None:\n        \"\"\"Set parameters from Python dict.\"\"\"\n        self.parameters_json = json.dumps(value) if value else None\n    \n    @hybrid_property\n    def tags(self) -> List[str]:\n        \"\"\"Get tags as Python list.\"\"\"\n        if self.tags_json:\n            return json.loads(self.tags_json)\n        return []\n    \n    @tags.setter\n    def tags(self, value: List[str]) -> None:\n        \"\"\"Set tags from Python list.\"\"\"\n        self.tags_json = json.dumps(value) if value else None\n    \n    @validates('status')\n    def validate_status(self, key: str, status: str) -> str:\n        \"\"\"Validate status values.\"\"\"\n        allowed_statuses = ['running', 'completed', 'failed', 'paused', 'cancelled']\n        if status not in allowed_statuses:\n            raise ValueError(f\"Status must be one of {allowed_statuses}\")\n        return status\n    \n    def mark_completed(self) -> None:\n        \"\"\"Mark experiment as completed.\"\"\"\n        self.status = \"completed\"\n        self.completed_at = datetime.utcnow()\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"Get experiment summary.\"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"status\": self.status,\n            \"num_designs\": self.num_designs,\n            \"success_rate\": self.success_rate,\n            \"started_at\": self.started_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n    \n    def __repr__(self) -> str:\n        return f\"<Experiment(id='{self.id}', name='{self.name}', status='{self.status}')>\"\n\n\nclass Constraint(Base, UUIDMixin, TimestampMixin):\n    \"\"\"\n    Design constraint storage model.\n    \n    Stores constraints used in protein design.\n    \"\"\"\n    \n    __tablename__ = \"constraints\"\n    \n    # Constraint identification\n    name = Column(String(255), nullable=False)\n    constraint_type = Column(String(100), nullable=False, index=True)\n    \n    # Constraint parameters\n    parameters_json = Column(Text, nullable=False)  # JSON-encoded constraint params\n    weight = Column(Float, default=1.0)\n    tolerance = Column(Float, default=0.1)\n    is_required = Column(Boolean, default=True)\n    \n    # Associated design\n    design_id = Column(String(36), ForeignKey(\"protein_designs.id\"), nullable=False, index=True)\n    \n    # Constraint satisfaction\n    is_satisfied = Column(Boolean)\n    satisfaction_score = Column(Float)\n    \n    # Relationships\n    design = relationship(\"ProteinDesign\", back_populates=\"constraints\")\n    \n    @hybrid_property\n    def parameters(self) -> Dict[str, Any]:\n        \"\"\"Get constraint parameters.\"\"\"\n        return json.loads(self.parameters_json)\n    \n    @parameters.setter\n    def parameters(self, value: Dict[str, Any]) -> None:\n        \"\"\"Set constraint parameters.\"\"\"\n        self.parameters_json = json.dumps(value)\n    \n    @validates('constraint_type')\n    def validate_constraint_type(self, key: str, constraint_type: str) -> str:\n        \"\"\"Validate constraint type.\"\"\"\n        allowed_types = [\n            'binding_site', 'secondary_structure', 'stability',\n            'catalytic', 'allosteric', 'disulfide_bond',\n            'metal_site', 'fold', 'custom'\n        ]\n        if constraint_type not in allowed_types:\n            raise ValueError(f\"Constraint type must be one of {allowed_types}\")\n        return constraint_type\n    \n    def __repr__(self) -> str:\n        return f\"<Constraint(id='{self.id}', type='{self.constraint_type}', satisfied={self.is_satisfied})>\"\n\n\nclass ValidationResult(Base, UUIDMixin, TimestampMixin):\n    \"\"\"\n    Structure validation result storage.\n    \n    Stores results from structure validation checks.\n    \"\"\"\n    \n    __tablename__ = \"validation_results\"\n    \n    # Associated design\n    design_id = Column(String(36), ForeignKey(\"protein_designs.id\"), nullable=False, index=True)\n    \n    # Validation type and method\n    validation_type = Column(String(100), nullable=False)  # stereochemistry, energy, etc.\n    validation_method = Column(String(100))  # tool/algorithm used\n    \n    # Results\n    is_valid = Column(Boolean, nullable=False)\n    score = Column(Float)\n    details_json = Column(Text)  # JSON-encoded detailed results\n    \n    # Error information\n    error_message = Column(Text)\n    warnings_json = Column(Text)  # JSON-encoded warnings\n    \n    # Relationships\n    design = relationship(\"ProteinDesign\", back_populates=\"validation_results\")\n    \n    @hybrid_property\n    def details(self) -> Dict[str, Any]:\n        \"\"\"Get validation details.\"\"\"\n        if self.details_json:\n            return json.loads(self.details_json)\n        return {}\n    \n    @details.setter\n    def details(self, value: Dict[str, Any]) -> None:\n        \"\"\"Set validation details.\"\"\"\n        self.details_json = json.dumps(value) if value else None\n    \n    @hybrid_property\n    def warnings(self) -> List[str]:\n        \"\"\"Get validation warnings.\"\"\"\n        if self.warnings_json:\n            return json.loads(self.warnings_json)\n        return []\n    \n    @warnings.setter\n    def warnings(self, value: List[str]) -> None:\n        \"\"\"Set validation warnings.\"\"\"\n        self.warnings_json = json.dumps(value) if value else None\n    \n    def __repr__(self) -> str:\n        return f\"<ValidationResult(id='{self.id}', type='{self.validation_type}', valid={self.is_valid})>\"\n\n\nclass PerformanceMetric(Base, UUIDMixin, TimestampMixin):\n    \"\"\"\n    Performance metric storage.\n    \n    Stores computational performance metrics for designs.\n    \"\"\"\n    \n    __tablename__ = \"performance_metrics\"\n    \n    # Associated design\n    design_id = Column(String(36), ForeignKey(\"protein_designs.id\"), nullable=False, index=True)\n    \n    # Metric identification\n    metric_name = Column(String(100), nullable=False, index=True)\n    metric_category = Column(String(50))  # timing, memory, quality, etc.\n    \n    # Metric values\n    value = Column(Float, nullable=False)\n    unit = Column(String(50))  # seconds, MB, score, etc.\n    \n    # Context\n    context_json = Column(Text)  # JSON-encoded context (device, batch_size, etc.)\n    \n    # Relationships\n    design = relationship(\"ProteinDesign\", back_populates=\"performance_metrics\")\n    \n    @hybrid_property\n    def context(self) -> Dict[str, Any]:\n        \"\"\"Get metric context.\"\"\"\n        if self.context_json:\n            return json.loads(self.context_json)\n        return {}\n    \n    @context.setter\n    def context(self, value: Dict[str, Any]) -> None:\n        \"\"\"Set metric context.\"\"\"\n        self.context_json = json.dumps(value) if value else None\n    \n    def __repr__(self) -> str:\n        return f\"<PerformanceMetric(id='{self.id}', name='{self.metric_name}', value={self.value})>\"\n\n\n# Create indexes for better query performance\nsa.Index('idx_protein_designs_status', ProteinDesign.status)\nsa.Index('idx_protein_designs_operator', ProteinDesign.operator_type)\nsa.Index('idx_protein_designs_length', ProteinDesign.length)\nsa.Index('idx_experiments_status', Experiment.status)\nsa.Index('idx_constraints_type', Constraint.constraint_type)\nsa.Index('idx_validation_type', ValidationResult.validation_type)\nsa.Index('idx_metrics_name', PerformanceMetric.metric_name)