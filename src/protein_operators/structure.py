"""
Protein structure representation and manipulation.
"""

from typing import Optional, Dict, Any, List
import torch
import numpy as np
from pathlib import Path


class ProteinStructure:
    """
    Protein structure representation with coordinates and metadata.
    
    This class provides methods for loading, saving, and manipulating
    protein structures generated by neural operators.
    """
    
    def __init__(
        self,
        coordinates: torch.Tensor,
        constraints: Optional["Constraints"] = None,
        sequence: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize protein structure.
        
        Args:
            coordinates: 3D coordinates [num_residues, 3]
            constraints: Design constraints used
            sequence: Amino acid sequence
            metadata: Additional structure metadata
        """
        self.coordinates = coordinates
        self.constraints = constraints
        self.sequence = sequence
        self.metadata = metadata or {}
        
    @property
    def num_residues(self) -> int:
        """Number of residues in the structure."""
        return self.coordinates.shape[0] if len(self.coordinates.shape) > 1 else 1
        
    def save_pdb(self, path: Path) -> None:
        """
        Save structure to PDB file.
        
        Args:
            path: Output PDB file path
        """
        import datetime
        import numpy as np
        
        coords = self.coordinates.detach().cpu().numpy()
        sequence = getattr(self, 'sequence', 'A' * len(coords))
        
        with open(path, 'w') as f:
            # PDB header with proper formatting
            f.write("HEADER    PROTEIN DESIGN                          "
                   f"{datetime.datetime.now().strftime('%d-%b-%y')}   XXXX\n")
            f.write("TITLE     PROTEIN GENERATED BY PROTEIN-OPERATORS\n")
            f.write(f"REMARK   1 GENERATED STRUCTURE WITH {len(coords)} RESIDUES\n")
            f.write(f"REMARK   2 OPERATOR TYPE: {getattr(self, 'operator_type', 'UNKNOWN')}\n")
            
            # Add constraint information if available
            if hasattr(self, 'constraints') and self.constraints:
                f.write("REMARK   3 DESIGN CONSTRAINTS:\n")
                if hasattr(self.constraints, 'binding_sites') and self.constraints.binding_sites:
                    f.write(f"REMARK   3  BINDING SITES: {len(self.constraints.binding_sites)}\n")
                if hasattr(self.constraints, 'secondary_structure') and self.constraints.secondary_structure:
                    f.write(f"REMARK   3  SECONDARY STRUCTURE: {len(self.constraints.secondary_structure)}\n")
            
            f.write("MODEL        1\n")
            
            atom_number = 1
            
            # Write atoms with backbone atoms for better visualization
            for i, (coord, aa) in enumerate(zip(coords, sequence)):
                residue_number = i + 1
                
                # CA atom (main coordinate)
                f.write(f"ATOM  {atom_number:5d}  CA  {aa} A{residue_number:4d}    "
                       f"{coord[0]:8.3f}{coord[1]:8.3f}{coord[2]:8.3f}"
                       f"  1.00 20.00           C\n")
                atom_number += 1
                
                # Add CB atom for better visualization (except for glycine)
                if aa != 'G':
                    cb_offset = np.array([0.5, 1.5, 0.5])  # Simplified CB position
                    cb_coord = coord + cb_offset
                    f.write(f"ATOM  {atom_number:5d}  CB  {aa} A{residue_number:4d}    "
                           f"{cb_coord[0]:8.3f}{cb_coord[1]:8.3f}{cb_coord[2]:8.3f}"
                           f"  1.00 20.00           C\n")
                    atom_number += 1
            
            f.write("ENDMDL\n")
            f.write("END\n")
            
    @classmethod
    def from_pdb(cls, path: Path) -> "ProteinStructure":
        """
        Load structure from PDB file.
        
        Args:
            path: Input PDB file path
            
        Returns:
            ProteinStructure object
        """
        import re
        
        coordinates = []
        sequence = []
        
        try:
            with open(path, 'r') as f:
                lines = f.readlines()
                
            for line in lines:
                if line.startswith('ATOM'):
                    # Parse PDB ATOM record
                    # Format: ATOM  serial atom res chain resSeq    x     y     z  occ  temp element
                    atom_name = line[12:16].strip()
                    residue_name = line[17:20].strip()
                    x = float(line[30:38])
                    y = float(line[38:46]) 
                    z = float(line[46:54])
                    
                    # Only take CA atoms for backbone representation
                    if atom_name == 'CA':
                        coordinates.append([x, y, z])
                        
                        # Convert 3-letter to 1-letter amino acid code
                        aa_map = {
                            'ALA': 'A', 'ARG': 'R', 'ASN': 'N', 'ASP': 'D',
                            'CYS': 'C', 'GLU': 'E', 'GLN': 'Q', 'GLY': 'G',
                            'HIS': 'H', 'ILE': 'I', 'LEU': 'L', 'LYS': 'K',
                            'MET': 'M', 'PHE': 'F', 'PRO': 'P', 'SER': 'S',
                            'THR': 'T', 'TRP': 'W', 'TYR': 'Y', 'VAL': 'V'
                        }
                        sequence.append(aa_map.get(residue_name, 'X'))
            
            if not coordinates:
                raise ValueError("No CA atoms found in PDB file")
            
            # Convert to tensor
            coord_tensor = torch.tensor(coordinates, dtype=torch.float32)
            
            # Create structure
            structure = cls(coord_tensor)
            structure.sequence = ''.join(sequence)
            
            return structure
            
        except FileNotFoundError:
            raise FileNotFoundError(f"PDB file not found: {path}")
        except Exception as e:
            raise ValueError(f"Error parsing PDB file: {str(e)}")
        
    def compute_rmsd(self, other: "ProteinStructure") -> float:
        """
        Compute RMSD to another structure.
        
        Args:
            other: Other protein structure
            
        Returns:
            RMSD value
        """
        if self.num_residues != other.num_residues:
            raise ValueError("Structures must have same number of residues")
            
        diff = self.coordinates - other.coordinates
        rmsd = torch.sqrt(torch.mean(diff ** 2))
        return rmsd.item()
        
    def center_coordinates(self) -> None:
        """Center coordinates at origin."""
        centroid = torch.mean(self.coordinates, dim=0)
        self.coordinates -= centroid
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert structure to dictionary representation."""
        return {
            "coordinates": self.coordinates.tolist(),
            "sequence": self.sequence,
            "num_residues": self.num_residues,
            "metadata": self.metadata,
        }
    
    def compute_radius_of_gyration(self) -> float:
        """Compute radius of gyration."""
        centroid = torch.mean(self.coordinates, dim=0)
        distances_sq = torch.sum((self.coordinates - centroid) ** 2, dim=1)
        rg = torch.sqrt(torch.mean(distances_sq))
        return rg.item()
    
    def compute_distance_matrix(self) -> torch.Tensor:
        """Compute pairwise distance matrix."""
        return torch.cdist(self.coordinates, self.coordinates)
    
    def compute_contact_map(self, cutoff: float = 8.0) -> torch.Tensor:
        """Compute residue contact map."""
        dist_matrix = self.compute_distance_matrix()
        contact_map = (dist_matrix < cutoff).float()
        # Zero out diagonal and nearby residues
        n = contact_map.size(0)
        for i in range(3):
            idx = torch.arange(n - i)
            contact_map[idx, idx + i] = 0
            if i > 0:
                contact_map[idx + i, idx] = 0
        return contact_map
    
    def validate_geometry(self) -> Dict[str, float]:
        """Validate protein geometry."""
        validation_results = {}
        
        # Bond length validation
        if self.num_residues > 1:
            bond_lengths = torch.norm(
                self.coordinates[1:] - self.coordinates[:-1], dim=1
            )
            ideal_ca_distance = 3.8  # Angstroms
            bond_deviations = torch.abs(bond_lengths - ideal_ca_distance)
            validation_results['avg_bond_deviation'] = torch.mean(bond_deviations).item()
            validation_results['max_bond_deviation'] = torch.max(bond_deviations).item()
        
        # Clash detection
        if self.num_residues > 2:
            dist_matrix = self.compute_distance_matrix()
            # Mask out bonded neighbors
            mask = torch.ones_like(dist_matrix)
            n = dist_matrix.size(0)
            for i in range(3):
                idx = torch.arange(n - i)
                mask[idx, idx + i] = 0
                if i > 0:
                    mask[idx + i, idx] = 0
            
            clash_cutoff = 2.0  # Angstroms
            clashes = torch.sum((dist_matrix < clash_cutoff) & (mask > 0))
            validation_results['num_clashes'] = clashes.item()
        
        # Compactness
        validation_results['radius_of_gyration'] = self.compute_radius_of_gyration()
        
        return validation_results
    
    def apply_transformation(self, rotation: torch.Tensor, translation: torch.Tensor) -> None:
        """Apply rotation and translation to coordinates."""
        if rotation.shape != (3, 3):
            raise ValueError("Rotation matrix must be 3x3")
        if translation.shape != (3,):
            raise ValueError("Translation vector must be length 3")
        
        self.coordinates = torch.matmul(self.coordinates, rotation.T) + translation
    
    def align_to(self, reference: "ProteinStructure") -> float:
        """Align structure to reference using Kabsch algorithm (simplified)."""
        if self.num_residues != reference.num_residues:
            raise ValueError("Structures must have same number of residues")
        
        # Center both structures
        coords1 = self.coordinates - torch.mean(self.coordinates, dim=0)
        coords2 = reference.coordinates - torch.mean(reference.coordinates, dim=0)
        
        # Compute covariance matrix
        H = torch.matmul(coords1.T, coords2)
        
        # SVD for optimal rotation
        try:
            U, S, V = torch.svd(H)
            R = torch.matmul(V, U.T)
            
            # Ensure proper rotation (det(R) = 1)
            if torch.det(R) < 0:
                V[:, -1] *= -1
                R = torch.matmul(V, U.T)
            
            # Apply transformation
            self.coordinates = torch.matmul(coords1, R) + torch.mean(reference.coordinates, dim=0)
            
            # Return RMSD after alignment
            return self.compute_rmsd(reference)
            
        except Exception:
            # Fallback: simple translation alignment
            translation = torch.mean(reference.coordinates, dim=0) - torch.mean(self.coordinates, dim=0)
            self.coordinates += translation
            return self.compute_rmsd(reference)
    
    def extract_fragment(self, start: int, end: int) -> "ProteinStructure":
        """Extract a fragment of the structure."""
        if start < 0 or end > self.num_residues or start >= end:
            raise ValueError("Invalid fragment indices")
        
        fragment_coords = self.coordinates[start:end]
        fragment_sequence = self.sequence[start:end] if self.sequence else None
        
        return ProteinStructure(
            coordinates=fragment_coords,
            sequence=fragment_sequence,
            metadata={**self.metadata, 'fragment_range': (start, end)}
        )
    
    def compute_secondary_structure_simple(self) -> List[str]:
        """Simple secondary structure assignment based on phi/psi angles."""
        if self.num_residues < 4:
            return ['C'] * self.num_residues  # All coil
        
        ss_assignment = ['C'] * self.num_residues
        
        # Simplified assignment based on local geometry
        for i in range(1, self.num_residues - 1):
            # Compute angle between consecutive CA-CA vectors
            v1 = self.coordinates[i] - self.coordinates[i-1] 
            v2 = self.coordinates[i+1] - self.coordinates[i]
            
            v1_norm = torch.nn.functional.normalize(v1.unsqueeze(0), dim=1).squeeze(0)
            v2_norm = torch.nn.functional.normalize(v2.unsqueeze(0), dim=1).squeeze(0)
            
            cos_angle = torch.dot(v1_norm, v2_norm)
            
            # Simple heuristic: sharp turns suggest beta, gradual turns suggest alpha
            if cos_angle > 0.5:  # < 60 degrees - extended
                ss_assignment[i] = 'E'
            elif cos_angle > -0.5:  # 60-120 degrees - turn/loop
                ss_assignment[i] = 'C'
            else:  # > 120 degrees - helical
                ss_assignment[i] = 'H'
        
        return ss_assignment